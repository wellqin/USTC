# -*- coding: utf-8 -*-
"""
-------------------------------------------------
File Name:        shell排序
Description :   
Author :          wellqin
date:             2019/10/9
Change Activity:  2019/10/9
-------------------------------------------------
"""
"""
一、希尔排序的介绍
希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的记录越来越多，当增量减至1时，
整个文件恰被分成一组，算法便终止。

二、希尔排序的原理
在前面文章中介绍的直接插入排序，它对于已经基本有序的数据进行排序，效率会很高，而如果对于最初的数据是倒序排列的，
则每次比较都需要移动数据，导致算法效率降低。
      希尔排序的基本思想就是：将需要排序的序列逻辑上划分为若干个较小的序列（但并非真的分割成若干分区），
      对这些逻辑上序列进行直接插入排序，通过这样的操作可使需要排序的数列基本有序，最后再使用一次直接插入排序。
      在希尔排序中首先要解决的是怎样划分序列，对于子序列的构成不是简单地分段，而是采取将相隔某个增量的数据组成一个序列。
      一般选择增量的规则是：取上一个增量的一半作为此次子序列划分的增量，一般初始值元素的总数量的一半。
"""


def shell_sort(alist):
    # 需要排序数组的个数
    N = len(alist)
    # 最初选取的步长
    gap = N // 2

    # 根据每次不同的步长，对分组内的数据进行排序
    # 如果步长没有减为1就继续执行
    while gap > 0:
        # 对每个分组进行插入排序，
        # 因为插入排序从第二个元素开始，而这里第二个元素的下标就是gap
        # 所以i的起始点是gap
        for i in range(gap, N):
            # 控制每个分组内相邻的两个元素,逻辑上相邻的两个元素间距为gap，
            # j的前一个元素比它少一个gap距离，所以for循环中j的步长为 -gap
            for j in range(i, 0, -gap):
                # 判断和逻辑上的分组相邻的两个数据大小
                if alist[j] < alist[j - gap] and j - gap >= 0:
                    # 交换
                    alist[j], alist[j - gap] = alist[j - gap], alist[j]
        # 改变步长
        gap = gap // 2


numlist = [5, 7, 8, 3, 1, 2, 4, 6, 9]
print("排序前：%s" % numlist)
shell_sort(numlist)
print("排序后：%s" % numlist)