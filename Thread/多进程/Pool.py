# -*- coding: utf-8 -*-
"""
-------------------------------------------------
File Name:        Pool
Description :   
Author :          wellqin
date:             2019/9/10
Change Activity:  2019/9/10
-------------------------------------------------
"""
"""
进程池Pool

当需要创建的⼦进程数量不多时，可以直接利⽤multiprocessing中的Process动态成⽣多个进程，

但如果是上百甚⾄上千个⽬标，⼿动的去创建进程的⼯作量巨⼤，此时就可以⽤到multiprocessing模块提供的Pool⽅法。

初始化Pool时，可以指定⼀个最⼤进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建⼀个新的进程⽤来执⾏该请求；但如果池中
的进程数已经达到指定的最⼤值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执⾏，请看下⾯的实例：


multiprocessing.Pool常⽤函数解析：
    apply_async(func[, args[, kwds]]) ：使⽤⾮阻塞⽅式调⽤func（并⾏执⾏，堵塞⽅式必须等待上⼀个进程退出才能执⾏下⼀个进程），args为
传递给func的参数列表，kwds为传递给func的关键字参数列表；
其作用是向进程池提交需要执行的函数及参数， 各个进程采用非阻塞（异步）的调用方式，即每个子进程只管运行自己的，不管其它进程是否已经完成。

    apply(func[, args[, kwds]])：使⽤阻塞⽅式调⽤func
    close()：关闭Pool，使其不再接受新的任务；
    terminate()：不管任务是否完成，⽴即终⽌；
    join()：主进程阻塞，等待⼦进程的退出， 必须在close或terminate之后使⽤；
    对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()或terminate()方法，让其不再接受新的Process了。
"""


from multiprocessing import Pool
import os, time
import random


def worker(msg):
    t_start = time.time()
    print("%s开始执⾏,进程号为%d" % (msg, os.getpid()))
    # random.random()随机⽣成0~1之间的浮点数
    time.sleep(random.random()*2)
    t_stop = time.time()
    print(msg, "执⾏完毕，耗时%0.2f" % (t_stop-t_start))


if __name__ == '__main__':

    po = Pool(8)   # 定义⼀个进程池，最⼤进程数3
    for i in range(0, 20):
        # Pool.apply_async(要调⽤的⽬标,(传递给⽬标的参数元祖,))
        # 每次循环将会⽤空闲出来的⼦进程去调⽤⽬标
        po.apply_async(worker, (i,))
    print("----start----")
    po.close()  # 关闭进程池，关闭后po不再接收新的请求
    po.join()   # 等待po中所有⼦进程执⾏完成，必须放在close语句之后
    """主进程创建添加任务后，默认不会等待进程池中的人物，执行完就结束
    加上join后，就会堵塞主进程去执行子进程，直到所有子进程完成后，主进程才退出"""
    print("-----end-----")

"""
----start----
0开始执⾏,进程号为19984
1开始执⾏,进程号为4980
2开始执⾏,进程号为17160
3开始执⾏,进程号为11768
4开始执⾏,进程号为23840
5开始执⾏,进程号为12636
6开始执⾏,进程号为15820
7开始执⾏,进程号为16856
3 执⾏完毕，耗时0.54
8开始执⾏,进程号为11768
1 执⾏完毕，耗时0.80
9开始执⾏,进程号为4980
4 执⾏完毕，耗时1.02
10开始执⾏,进程号为23840
0 执⾏完毕，耗时1.15
11开始执⾏,进程号为19984
7 执⾏完毕，耗时1.42
12开始执⾏,进程号为16856
10 执⾏完毕，耗时0.45
13开始执⾏,进程号为23840
13 执⾏完毕，耗时0.03
14开始执⾏,进程号为23840
2 执⾏完毕，耗时1.73
15开始执⾏,进程号为17160
5 执⾏完毕，耗时1.70
16开始执⾏,进程号为12636
6 执⾏完毕，耗时1.93
17开始执⾏,进程号为15820
14 执⾏完毕，耗时0.52
18开始执⾏,进程号为23840
16 执⾏完毕，耗时0.36
19开始执⾏,进程号为12636
9 执⾏完毕，耗时1.34
15 执⾏完毕，耗时0.59
19 执⾏完毕，耗时0.35
12 执⾏完毕，耗时0.98
8 执⾏完毕，耗时1.96
17 执⾏完毕，耗时0.61
11 执⾏完毕，耗时1.90
18 执⾏完毕，耗时1.59
-----end-----
"""


# apply堵塞式
def worker(msg):
    t_start = time.time()
    print("%s开始执⾏,进程号为%d"%(msg, os.getpid()))
    # random.random()随机⽣成0~1之间的浮点数
    time.sleep(random.random()*2)
    t_stop = time.time()
    print(msg, "执⾏完毕，耗时%0.2f" % (t_stop-t_start))


if __name__ == '__main__':
    po = Pool(3)  # 定义⼀个进程池，最⼤进程数3
    for i in range(0, 10):
        po.apply(worker, (i,))
    print("----start----")
    po.close()  # 关闭进程池，关闭后po不再接收新的请求
    po.join()   # 等待po中所有⼦进程执⾏完成，必须放在close语句之后
    print("-----end-----")

"""
0开始执⾏,进程号为26376
0 执⾏完毕，耗时0.36
1开始执⾏,进程号为8420
1 执⾏完毕，耗时0.71
2开始执⾏,进程号为9552
2 执⾏完毕，耗时1.13
3开始执⾏,进程号为26376
3 执⾏完毕，耗时0.92
4开始执⾏,进程号为8420
4 执⾏完毕，耗时0.84
5开始执⾏,进程号为9552
5 执⾏完毕，耗时0.11
6开始执⾏,进程号为26376
6 执⾏完毕，耗时0.22
7开始执⾏,进程号为8420
7 执⾏完毕，耗时1.75
8开始执⾏,进程号为9552
8 执⾏完毕，耗时1.13
9开始执⾏,进程号为26376
9 执⾏完毕，耗时0.12
----start----
-----end-----
"""